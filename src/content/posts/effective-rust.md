---
title: 'Effective Rust é€ŸæŸ¥è¡¨ï¼ˆæ­£åœ¨æ–½å·¥ï¼‰'
description: 'Effective Rust é€ŸæŸ¥è¡¨'
date: '2024-04-25 03:25:00'
tags: ['rust']
author: 'ğŸ± å¯’å†°'
---

# Effective Rust

## ä¸€. ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¡¨è¾¾æ•°æ®ç»“æ„

1. Rust isn't a language where you're going to be doing much in the way of converting between pointers and integers â€” åœ¨ C / C++ ä¸­æ˜¯å…è®¸æ“ä½œå†…å­˜åœ°å€çš„ï¼Œæ¯”å¦‚åŠ å‡å†…å­˜åœ°å€
2. Rust å…è®¸åœ¨æ•°å­—å­—é¢é‡å£°æ˜ç±»å‹ï¼š
   
    ```jsx
    let x = 23i32;
    ```
    
3. Rust çš„ `char` å­—ç¬¦ï¼Œåœ¨å†…å­˜ä¸­ä»ç„¶ä¿æŒä¸º 4 å­—èŠ‚ `Unicode` å€¼ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸º 32 ä½æ•´æ•°ã€‚
4. åœ¨ Rust ä¸­ä½¿ç”¨ `try_into()` è¿›è¡Œå¤§ä½æ•°çš„æ•°å­—ç±»å‹åˆ°å°ä½æ•°æ•°å­—ç±»å‹çš„è½¬æ¢ï¼Œä½¿ç”¨ `into()` è¿›è¡Œå°ä½æ•°åˆ°å¤§ä½æ•°çš„æ•°å­—ç±»å‹è½¬æ¢ã€‚
5. `Arrays` ç”¨äºèšåˆä¸€ä¸ªç±»å‹çš„å¤šä¸ªå®ä¾‹ã€‚`Tuple` ç”¨äºèšåˆå¤šä¸ªç±»å‹çš„å¤šä¸ªå®ä¾‹ï¼Œ`Structs` åŒæ ·ç”¨äºèšåˆå¤šä¸ªç±»å‹çš„å¤šä¸ªç±»å‹ã€‚ä½†æ˜¯å…è®¸é€šè¿‡åç§°æ¥å¼•ç”¨å„ä¸ªå­—æ®µã€‚
6. `enum` å…è®¸æºå¸¦ä¸€ä¸ªæ•°å­—æˆ–å­—ç¬¦ä¸²å€¼ï¼Œå¹¶ä¸”å…·æœ‰ç±»å‹å®‰å…¨æ£€æŸ¥ã€‚
7. ä½¿ç”¨ `match` çš„æ—¶å€™å»ºè®®æ·»åŠ  `_ â‡’ {}` ä½œä¸ºé»˜è®¤é€‰é¡¹ã€‚
8. åœ¨ Rust ä¸­ï¼Œè¡¨è¾¾å¯èƒ½å­˜åœ¨é”™è¯¯ä½¿ç”¨ `Result<T, E>`ï¼Œè¡¨è¾¾å¯èƒ½ä¸å­˜åœ¨å€¼ä½¿ç”¨ `Option<T>` ã€‚

## äºŒ. ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¡¨è¾¾å…±åŒè¡Œä¸º

1. `Method` æ–¹æ³•ï¼Œéœ€è¦ä¾é™„åœ¨ `enum` `structs` ç­‰ç»“æ„ä¸Šï¼Œé€šå¸¸ä¸º `impl ç»“æ„ä½“åç§°`ï¼Œåœ¨ `fn` å‰ä½¿ç”¨ `pub` è¡¨ç¤ºè¯¥æ–¹æ³•ä¸ºå…¬å¼€æ–¹æ³•ï¼Œå…è®¸ä» `impl` å—å¤–çš„åœ°æ–¹è°ƒç”¨ã€‚
2. Rust ä¸­å‘€å¾ˆå¤šå¾ˆæœ‰æ„æ€çš„å†™æ³•ï¼Œæ ¹æ®åŒ¹é… enum çš„å€¼åœ¨ä¸€ä¸ª impl çš„æ–¹æ³•ä¸­ä»¥ä¸åŒçš„æ–¹å¼è¿›è¡Œè®¡ç®—ï¼Œå¦‚ä¸‹ï¼š
   
    ```rust
    enum Shape {
        Rectangle { width: f64, height: f64 },
        Circle { radius: f64 },
    }
    
    impl Shape {
        pub fn area(&self) -> f64 {
            match self {
                Shape::Rectangle { width, height } => width * height,
                Shape::Circle { radius } => std::f64::consts::PI * radius * radius,
            }
        }
    }
    
    ```
    
3. Rust æ”¯æŒå‡½æ•°æŒ‡é’ˆï¼Œå…è®¸å°†ä¸€æ•´ä¸ªå‡½æ•°èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡ã€‚
4. Rust æ”¯æŒé—­åŒ…ï¼Œå³å°†å‡½æ•°ä½œä¸ºå¦ä¸€ä¸ªå‡½æ•°çš„å‚æ•°è¿›è¡Œä¼ é€’ï¼Œå½“ç„¶ lambda è¡¨è¾¾å¼æ”¯æŒä¹Ÿå°‘ä¸äº†ã€‚Rust çš„è¡¨è¾¾å¼è¯­æ³•ä¸º `|argsâ€¦| = { â€¦ };` ã€‚
   
    > å¯¹äº Rust è¯­è¨€è€Œè¨€ï¼Œ**è¿™ç§åŸºäºè¯­å¥ï¼ˆstatementï¼‰å’Œè¡¨è¾¾å¼ï¼ˆexpressionï¼‰çš„æ–¹å¼æ˜¯éå¸¸é‡è¦çš„ï¼Œä½ éœ€è¦èƒ½æ˜ç¡®çš„åŒºåˆ†è¿™ä¸¤ä¸ªæ¦‚å¿µ**, ä½†æ˜¯å¯¹äºå¾ˆå¤šå…¶å®ƒè¯­è¨€è€Œè¨€ï¼Œè¿™ä¸¤ä¸ªå¾€å¾€æ— éœ€åŒºåˆ†ã€‚åŸºäºè¡¨è¾¾å¼æ˜¯å‡½æ•°å¼è¯­è¨€çš„é‡è¦ç‰¹å¾ï¼Œ**è¡¨è¾¾å¼æ€»è¦è¿”å›å€¼**ã€‚ â€” åœ£ç»
    > 
5. å¯ä»¥ä½¿ç”¨ä¸€äº› Trait æ¥å¯¹ä½œä¸ºå‚æ•°ä¼ å…¥çš„å‡½æ•°ç±»å‹ä½œå‡ºé™åˆ¶ã€‚`FnOnce` æ˜¯æŒ‡ç§»äº¤æ‰€æœ‰æƒçš„å‚æ•°ï¼›`FnMut` ç›¸å½“äº `&mut T` æŒ‡ä¼ å…¥ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼›Fn ç›¸å½“äº &Tï¼ŒæŒ‡ä¼ å…¥å¼•ç”¨ã€‚
   
    ```rust
    pub fn modify_all<F>(data: &mut [u32], mut mutator: F)
    where
        F: FnMut(u32) -> u32,
    {
        for value in data {
            *value = mutator(*value);
        }
    }
    ```
    
6. Rust æ²¡æœ‰å‡½æ•°é‡è½½ï¼Œå‡½æ•°é‡è½½æœ‰è¿ Rust è®¾è®¡å“²å­¦ä¹‹ä¸€çš„ Be Explicitï¼Œè€Œå¤§å¤šæ•°æƒ…å†µéƒ½å¯ä»¥æ”¹ç”¨æ³›å‹è§£å†³ã€‚
   
    ```rust
    use num::Num;
    
    fn plus<T: Num>(a: T, b: T) -> T {
        a + b
    }
    ```
    
7. Rust å¯ä»¥ä¾æ® Trait é™åˆ¶æ³›å‹è¾¹ç•Œï¼ˆTrait boundsï¼‰ã€‚
   
    ```rust
    pub fn dump_sorted<T>(mut collection: T)
    where
        T: Sort + IntoIterator,
        T::Item: std::fmt::Debug,
    {
        // Next line requires `T: Sort` trait bound.
        collection.sort();
        // Next line requires `T: IntoIterator` trait bound.
        for item in collection {
            // Next line requires `T::Item : Debug` trait bound
            println!("{:?}", item);
        }
    }
    ```
    
